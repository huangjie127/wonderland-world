-- Create notifications table
create table if not exists notifications (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id) on delete cascade not null,
  type text not null check (type in ('relationship_request', 'relationship_termination', 'interaction', 'like')),
  title text not null,
  content text,
  data jsonb default '{}'::jsonb,
  is_read boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS
alter table notifications enable row level security;

-- Policies
create policy "Users can view their own notifications"
  on notifications for select
  using ( auth.uid() = user_id );

create policy "Users can update their own notifications"
  on notifications for update
  using ( auth.uid() = user_id );

-- Triggers to auto-create notifications

-- 1. Relationship Request Trigger
create or replace function notify_relationship_request()
returns trigger as $$
declare
  target_user_id uuid;
  from_char_name text;
begin
  -- Get target user id
  select user_id into target_user_id from characters where id = new.to_character_id;
  -- Get from character name
  select name into from_char_name from characters where id = new.from_character_id;
  
  if target_user_id is not null then
    insert into notifications (user_id, type, title, content, data)
    values (
      target_user_id,
      'relationship_request',
      '收到新的关系申请',
      from_char_name || ' 申请与您的角色建立关系',
      jsonb_build_object('request_id', new.id, 'from_character_id', new.from_character_id, 'to_character_id', new.to_character_id)
    );
  end if;
  return new;
end;
$$ language plpgsql security definer;

create trigger on_relationship_request_created
  after insert on character_relationship_requests
  for each row execute procedure notify_relationship_request();

-- 2. Relationship Termination Trigger
create or replace function notify_relationship_termination()
returns trigger as $$
declare
  target_user_id uuid;
  requester_name text;
  relationship_record record;
  requester_user_id uuid;
begin
  -- Get relationship details to find the other character
  select * into relationship_record from character_relationship_requests where id = new.relationship_id;
  
  -- Get requester user id
  select user_id into requester_user_id from characters where id = new.requested_by;
  
  -- Get Char 1 Owner
  declare
    char1_owner uuid;
    char2_owner uuid;
    char1_name text;
    char2_name text;
  begin
    select user_id, name into char1_owner, char1_name from characters where id = relationship_record.from_character_id;
    select user_id, name into char2_owner, char2_name from characters where id = relationship_record.to_character_id;
    
    if char1_owner != requester_user_id then
        insert into notifications (user_id, type, title, content, data)
        values (char1_owner, 'relationship_termination', '收到关系解除请求', '有人请求解除与 ' || char1_name || ' 的关系', jsonb_build_object('termination_id', new.id));
    end if;
    
    if char2_owner != requester_user_id then
        insert into notifications (user_id, type, title, content, data)
        values (char2_owner, 'relationship_termination', '收到关系解除请求', '有人请求解除与 ' || char2_name || ' 的关系', jsonb_build_object('termination_id', new.id));
    end if;
  end;
  
  return new;
end;
$$ language plpgsql security definer;

create trigger on_relationship_termination_created
  after insert on character_relationship_terminations
  for each row execute procedure notify_relationship_termination();

-- 3. Interaction (Guestbook) Trigger
create or replace function notify_interaction()
returns trigger as $$
declare
  target_user_id uuid;
  guest_name text;
begin
  -- Get host character owner
  select user_id into target_user_id from characters where id = new.host_character_id;
  -- Get guest name
  select name into guest_name from characters where id = new.guest_character_id;
  
  -- Don't notify if commenting on own character (optional, but good UX)
  if target_user_id != auth.uid() then
    insert into notifications (user_id, type, title, content, data)
    values (
      target_user_id,
      'interaction',
      '收到新留言',
      guest_name || ' 给您的角色留言了',
      jsonb_build_object('interaction_id', new.id, 'host_character_id', new.host_character_id)
    );
  end if;
  return new;
end;
$$ language plpgsql security definer;

create trigger on_interaction_created
  after insert on character_interactions
  for each row execute procedure notify_interaction();

-- 4. Like Trigger
create or replace function notify_like()
returns trigger as $$
declare
  target_user_id uuid;
begin
  -- Get character owner
  select user_id into target_user_id from characters where id = new.character_id;
  
  -- Don't notify self-likes (though UI prevents it, API might not)
  if target_user_id != new.user_id then
    insert into notifications (user_id, type, title, content, data)
    values (
      target_user_id,
      'like',
      '收到新点赞',
      '有人点赞了您的角色',
      jsonb_build_object('character_id', new.character_id)
    );
  end if;
  return new;
end;
$$ language plpgsql security definer;

create trigger on_like_created
  after insert on character_likes
  for each row execute procedure notify_like();
